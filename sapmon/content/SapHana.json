{
    "checks": [
        {
            "name": "HostConfig",
            "description": "SAP HANA Host Config",
            "customLog": "SapHana_HostConfig",
            "frequencySecs": 60,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT hi.VALUE AS IP, lhc.* FROM SYS.M_LANDSCAPE_HOST_CONFIGURATION lhc LEFT OUTER JOIN SYS.M_HOST_INFORMATION hi ON lhc.HOST=hi.HOST AND hi.KEY='net_publicname' ORDER BY HOST_ACTIVE DESC, INDEXSERVER_ACTUAL_ROLE ASC"
                    }
                },
                {
                    "type": "ParseHostConfig"
                }
            ]
        },
        {
            "name": "HostInformation",
            "description": "SAP HANA Host Information",
            "customLog": "SapHana_HostInformation",
            "frequencySecs": 86400,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT * FROM SYS.M_HOST_INFORMATION"
                    }
                }
            ]
        },
        {
            "name": "SystemOverview",
            "description": "SAP HANA System Overview",
            "customLog": "SapHana_SystemOverview",
            "frequencySecs": 86400,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT * FROM SYS.M_SYSTEM_OVERVIEW"
                    }
                }
            ]
        },
        {
            "name": "LoadHistory",
            "description": "SAP HANA Load History",
            "customLog": "SapHana_LoadHistory",
            "frequencySecs": 60,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "isTimeSeries": true,
                        "initialTimespanSecs": 3600,
                        "sql": "SELECT lhh.TIME AS _SERVER_LOCALTIME, ADD_SECONDS(lhh.TIME, MAP(hi.VALUE, null, 0, hi.VALUE*(-1))) AS _TIMESERIES_UTC, lhh.HOST AS HOST, 'HOST' AS SCOPE, MAP(lhh.CPU, NULL, NULL, -1, NULL, ROUND(100 * lhh.CPU / 1) / 100) AS CPU, MAP(lhh.MEMORY_RESIDENT, NULL, NULL, -1, NULL, ROUND(100 * lhh.MEMORY_RESIDENT / 1048576) / 100) AS MEMORY_RESIDENT, MAP(lhh.MEMORY_TOTAL_RESIDENT, NULL, NULL, -1, NULL, ROUND(100 * lhh.MEMORY_TOTAL_RESIDENT / 1048576) / 100) AS MEMORY_TOTAL_RESIDENT, MAP(lhh.MEMORY_SIZE, NULL, NULL, -1, NULL, ROUND(100 * lhh.MEMORY_SIZE / 1048576) / 100) AS MEMORY_SIZE, MAP(lhh.MEMORY_USED, NULL, NULL, -1, NULL, ROUND(100 * lhh.MEMORY_USED / 1048576) / 100) AS MEMORY_USED, MAP(lhh.MEMORY_ALLOCATION_LIMIT, NULL, NULL, -1, NULL, ROUND(100 * lhh.MEMORY_ALLOCATION_LIMIT / 1048576) / 100) AS MEMORY_ALLOCATION_LIMIT, MAP(lhh.DISK_USED, NULL, NULL, -1, NULL, ROUND(100 * lhh.DISK_USED / 1073741824) / 100) AS DISK_USED, MAP(lhh.DISK_SIZE, NULL, NULL, -1, NULL, ROUND(100 * lhh.DISK_SIZE / 1073741824) / 100) AS DISK_SIZE, MAP(LAG(lhh.TIME) OVER (ORDER BY lhh.HOST, lhh.TIME), NULL, NULL, MAP(SUBSTRING(CAST(lhh.NETWORK_IN AS VARCHAR), 0, 1), '-', NULL, 'n', NULL, ROUND(10000000 * (100 * lhh.NETWORK_IN / (NANO100_BETWEEN(LAG(lhh.TIME) OVER (ORDER BY lhh.HOST, lhh.TIME), lhh.TIME))) / 1048576) / 100)) AS NETWORK_IN, MAP(LAG(lhh.TIME) OVER (ORDER BY lhh.HOST, lhh.TIME), NULL, -1, MAP(SUBSTRING(CAST(lhh.NETWORK_OUT AS VARCHAR), 0, 1), '-', NULL, 'n', NULL, ROUND(10000000 * (100 * lhh.NETWORK_OUT / (NANO100_BETWEEN(LAG(lhh.TIME) OVER (ORDER BY lhh.HOST, lhh. TIME), lhh.TIME))) / 1048576) / 100)) AS NETWORK_OUT FROM SYS.M_LOAD_HISTORY_HOST lhh LEFT OUTER JOIN SYS.M_HOST_INFORMATION hi ON (lhh.HOST = hi.HOST AND UPPER(hi.KEY) = 'TIMEZONE_OFFSET') WHERE ADD_SECONDS(lhh.TIME, MAP(hi.VALUE, null, 0, hi.VALUE*(-1))) > {lastRunServerUtc} ORDER BY lhh.TIME ASC"
                    }
                }
            ]
        },
        {
            "name": "Disks",
            "description": "SAP HANA Disks",
            "customLog": "SapHana_Disks",
            "frequencySecs": 3600,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT HOST, PATH, SUBPATH, USAGE_TYPE, USED_SIZE, TOTAL_SIZE FROM SYS.M_DISKS"
                    }
                }
            ]
        },
        {
            "name": "SystemAvailability",
            "description": "SAP HANA System Availability",
            "customLog": "SapHana_SystemAvailability",
            "frequencySecs": 60,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "isTimeSeries": true,
                        "initialTimespanSecs": 86400,
                        "sql": "SELECT sa.EVENT_TIME AS _SERVER_LOCALTIME, ADD_SECONDS(sa.EVENT_TIME, MAP(hi.VALUE, null, 0, hi.VALUE*(-1))) AS _TIMESERIES_UTC, sa.* FROM SYS.M_SYSTEM_AVAILABILITY sa LEFT OUTER JOIN SYS.M_HOST_INFORMATION hi ON (sa.HOST = hi.HOST AND UPPER(hi.KEY) = 'TIMEZONE_OFFSET') WHERE ADD_SECONDS(sa.EVENT_TIME, MAP(hi.VALUE, null, 0, hi.VALUE*(-1))) > {lastRunServerUtc} ORDER BY sa.EVENT_TIME ASC"
                    }
                }
            ]
        },
        {
            "name": "SqlProbe",
            "description": "Probe for SAP HANA SQL connection",
            "customLog": "SapHana_SqlProbe",
            "enabled": false,
            "frequencySecs": 60,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ProbeSqlConnection",
                    "parameters": {
                        "probeTimeout": 3000
                    }
                }
            ]
        },
        {
            "name": "BackupCatalog",
            "description": "SAP HANA Backup Catalog",
            "customLog": "SapHana_BackupCatalog",
            "frequencySecs": 300,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "isTimeSeries": true,
                        "initialTimespanSecs": 604800,
                        "sql": "SELECT (SELECT TOP 1 hi.VALUE FROM SYS.M_HOST_INFORMATION AS hi WHERE UPPER(hi.KEY) = 'SID') AS SYSTEM_ID, hi.VALUE, MBC.DATABASE_NAME, MBC.ENTRY_TYPE_NAME, MBC.BACKUP_ID, MIN(MBC.UTC_START_TIME) AS UTC_START_TIME, MAX(MBC.UTC_END_TIME) AS UTC_END_TIME, ((NANO100_BETWEEN(MIN(MBC.UTC_START_TIME), MAX(MBC.UTC_END_TIME)) / 10000000) ) AS TIME_ELAPSED_SECONDS, MBC.STATE_NAME, MBC.MESSAGE, SUM(MBCF.BACKUP_SIZE / (SELECT MAP(COUNT(hi.VALUE), 0, 1, COUNT(hi.VALUE)) FROM SYS.M_HOST_INFORMATION hi WHERE UPPER(hi.KEY) = 'TIMEZONE_OFFSET')) AS BACKUP_SIZE_BYTES, SUM(MBCF.BACKUP_SIZE / (SELECT MAP(COUNT(hi.VALUE), 0, 1, COUNT(hi.VALUE)) FROM SYS.M_HOST_INFORMATION hi WHERE UPPER(hi.KEY) = 'TIMEZONE_OFFSET')) / ((NANO100_BETWEEN(MIN(MBC.UTC_START_TIME), MAX(MBC.UTC_END_TIME)) / 10000000) ) AS BACKUP_RATE_KBYTES_PER_SECOND, (COUNT(*) / (SELECT MAP(COUNT(hi.VALUE), 0, 1, COUNT(hi.VALUE)) FROM SYS.M_HOST_INFORMATION hi WHERE UPPER(hi.KEY) = 'TIMEZONE_OFFSET')) AS NUMBER_OF_FILES, MBCF.DESTINATION_TYPE_NAME, CURRENT_TIMESTAMP AS _SERVER_LOCALTIME, CURRENT_UTCTIMESTAMP AS _SERVER_UTC, CURRENT_UTCTIMESTAMP AS _TIMESERIES_UTC FROM SYS_DATABASES.M_BACKUP_CATALOG AS MBC INNER JOIN SYS_DATABASES.M_BACKUP_CATALOG_FILES AS MBCF ON MBC.ENTRY_ID = MBCF.ENTRY_ID LEFT OUTER JOIN SYS.M_HOST_INFORMATION hi ON UPPER(hi.KEY) = 'TIMEZONE_OFFSET' WHERE MBC.STATE_NAME NOT LIKE 'running' AND MBC.UTC_END_TIME > {lastRunServerUtc} GROUP BY SYSTEM_ID, MBC.DATABASE_NAME, MBC.ENTRY_TYPE_NAME, MBC.BACKUP_ID, MBC.STATE_NAME, MBC.MESSAGE, MBCF.DESTINATION_TYPE_NAME, MBC.UTC_END_TIME, hi.VALUE ORDER BY MBC.BACKUP_ID DESC"
                    }
                }
            ]
        },
        {
            "name": "SystemReplication",
            "description": "SAP HANA System Replication",
            "customLog": "SapHana_SystemReplication",
            "frequencySecs": 60,
            "includeInCustomerAnalytics": true,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT MHI.VALUE AS SYSTEM_ID, MSRVR.HOST, MSRV.SERVICE_NAME, MSRV.ACTIVE_STATUS, MSRVR.SITE_NAME, MSRVR.DATABASE_NAME, MSRVR.SECONDARY_HOST, MSRVR.SECONDARY_SITE_NAME, MSRVR.REPLICATION_MODE, MSYSR.OPERATION_MODE, MSYSR.TIER, MSYSR.REPLICATION_STATUS AS SYSTEM_REPLICATION_STATUS, MSRVR.REPLICATION_STATUS AS SERVICE_REPLICATION_STATUS, MSRVR.REPLICATION_STATUS_DETAILS AS SERVICE_REPLICATION_STATUS_DETAILS, MSRVR.SECONDARY_FULLY_RECOVERABLE, MSRVR.FULL_SYNC, MSRVR.SHIPPED_LOG_BUFFERS_SIZE, MSRVR.SHIPPED_LOG_BUFFERS_COUNT, MSRVR.SHIPPED_LOG_BUFFERS_DURATION, MSRVR.SHIPPED_FULL_REPLICA_SIZE, MSRVR.SHIPPED_FULL_REPLICA_DURATION, MSRVR.SECONDARY_RECONNECT_COUNT, MSRVR.SECONDARY_FAILOVER_COUNT, MSRVR.LAST_LOG_POSITION, MSRVR.LAST_LOG_POSITION_TIME, MSRVR.SHIPPED_LOG_POSITION, MSRVR.SHIPPED_LOG_POSITION_TIME, MSRVR.SHIPPED_SAVEPOINT_START_TIME, MSRVR.REPLAYED_LOG_POSITION, MSRVR.REPLAYED_LOG_POSITION_TIME, MVIOS.TOTAL_WRITE_SIZE, MVIOS.TOTAL_WRITE_TIME, MVIOS.TOTAL_TRIGGER_ASYNC_WRITES, SECONDS_BETWEEN(MSRVR.SHIPPED_LOG_POSITION_TIME, MSRVR.LAST_LOG_POSITION_TIME) AS TIME_DIFF_SECONDS, TO_DECIMAL((MSRVR.LAST_LOG_POSITION - MSRVR.SHIPPED_LOG_POSITION) * 64 / 1024 / 1024, 10, 2) AS ASYNC_BUFF_USED_MB, CURRENT_TIMESTAMP AS _SERVER_LOCALTIME, CURRENT_UTCTIMESTAMP AS _SERVER_UTC FROM SYS_DATABASES.M_SERVICE_REPLICATION AS MSRVR JOIN SYS_DATABASES.M_SYSTEM_REPLICATION AS MSYSR ON MSYSR.DATABASE_NAME = MSRVR.DATABASE_NAME AND MSYSR.SITE_ID = MSRVR.SITE_ID AND MSYSR.SECONDARY_SITE_ID = MSRVR.SECONDARY_SITE_ID LEFT OUTER JOIN SYS_DATABASES.M_VOLUME_IO_TOTAL_STATISTICS AS MVIOS ON MSRVR.DATABASE_NAME = MVIOS.DATABASE_NAME AND MSRVR.HOST = MVIOS.HOST AND MSRVR.PORT = MVIOS.PORT AND MVIOS.TYPE = 'LOG' LEFT OUTER JOIN SYS_DATABASES.M_SERVICES AS MSRV ON MSRVR.PORT = MSRV.PORT AND MSRVR.HOST = MSRV.HOST INNER JOIN SYS.M_HOST_INFORMATION AS MHI ON UPPER(MHI.KEY) = 'SID' AND MHI.HOST = MSRVR.HOST GROUP BY MHI.VALUE, MSRVR.HOST, MSRVR.PORT, MSRV.SERVICE_NAME, MSRV.ACTIVE_STATUS, MSRVR.SITE_NAME, MSRVR.DATABASE_NAME, MSRVR.SECONDARY_HOST, MSRVR.SECONDARY_SITE_NAME, MSRVR.REPLICATION_MODE, MSYSR.OPERATION_MODE, MSRVR.VOLUME_ID, MSYSR.TIER, MSYSR.REPLICATION_STATUS, MSRVR.REPLICATION_STATUS, MSRVR.REPLICATION_STATUS_DETAILS, MSRVR.SECONDARY_FULLY_RECOVERABLE, MSRVR.FULL_SYNC, MSRVR.SHIPPED_LOG_BUFFERS_SIZE, MSRVR.SHIPPED_LOG_BUFFERS_COUNT, MSRVR.SHIPPED_LOG_BUFFERS_DURATION, MSRVR.SHIPPED_FULL_REPLICA_SIZE, MSRVR.SHIPPED_FULL_REPLICA_DURATION, MSRVR.SECONDARY_RECONNECT_COUNT, MSRVR.SECONDARY_FAILOVER_COUNT, MSRVR.LAST_LOG_POSITION, MSRVR.LAST_LOG_POSITION_TIME, MSRVR.SHIPPED_LOG_POSITION, MSRVR.SHIPPED_LOG_POSITION_TIME, MSRVR.SHIPPED_SAVEPOINT_START_TIME, MSRVR.REPLAYED_LOG_POSITION, MSRVR.REPLAYED_LOG_POSITION_TIME, MVIOS.TOTAL_WRITE_SIZE, MVIOS.TOTAL_WRITE_TIME, MVIOS.TOTAL_TRIGGER_ASYNC_WRITES, MSRVR.LAST_LOG_POSITION, MSRVR.SHIPPED_LOG_POSITION ORDER BY MSRVR.SECONDARY_HOST DESC, MSRVR.VOLUME_ID ASC"
                    }
                }
            ]
        },
        {
            "name": "HANADatasize",
            "description": "SAP HANA size",
            "customLog": "SapHana_size01",
            "frequencySecs": 21600,
            "includeInCustomerAnalytics": false,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": " SELECT SYSTEM_ID, DATABASE_NAME, TABLE_NAME, ROUND(SUM(ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL/1024/1024/1024),3) ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL_GIB, ROUND(SUM((MEMORY_SIZE_IN_TOTAL)/1024/1024/1024),3) MEMORY_SIZE_IN_TOTAL_GIB, SUM(RECORD_COUNT) RECORDS, COUNT(*) PARTITION_COUNT FROM M_DATABASE, SYS.M_CS_TABLES GROUP BY SYSTEM_ID, DATABASE_NAME, TABLE_NAME  UNION ALL SELECT SYSTEM_ID, DATABASE_NAME, 'ALL_TABLES' as TABLE_NAME, ROUND(SUM(ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL/1024/1024/1024),3) ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL_GIB, ROUND(SUM((MEMORY_SIZE_IN_TOTAL)/1024/1024/1024),3) MEMORY_SIZE_IN_TOTAL_GIB, SUM(RECORD_COUNT) RECORDS, COUNT(*) PARTITION_COUNT, CURRENT_UTCTIMESTAMP AS _SERVER_UTC FROM DUMMY, M_DATABASE, SYS.M_CS_TABLES GROUP BY SYSTEM_ID, DATABASE_NAME ORDER BY ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL_GIB DESC  LIMIT 11"
                                  }
                }
            ]
        },
        {
            "name": "MVCC",
            "description": "SAP HANA Multiversion Concurrency Control (MVCC) count",
            "customLog": "SapHana_Mvcc",
            "frequencySecs": 86400,
            "includeInCustomerAnalytics": false,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT * FROM M_MVCC_TABLES WHERE (NAME='NUM_VERSIONS' OR NAME='MAX_VERSIONS_PER_RECORD' OR NAME='TABLE_ID_OF_MAX_NUM_VERSIONS')"
                                  }
                }
            ]
        },
        {
            "name": "IOSavepoint",
            "description": "SAP HANA IO Savepoint",
            "customLog": "SapHana_IO_Savepoint",
            "frequencySecs": 3600,
            "includeInCustomerAnalytics": false,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT START_TIME, BLK_PHASE_START_TIME, CRIT_PHASE_START_TIME, END_TIME, HOST, LPAD(PORT, 5) PORT, LPAD(VERSION, 8) VERSION, LPAD(NUM_SAVEPOINTS, 5) COUNT, MAP(PURPOSE, 'DROP_SNAPSHOT', 'DS', 'NORMAL', 'N', 'SNAPSHOT_FOR_REPLICATION', 'SFR', 'SNAPSHOT_FOR_BACKUP', 'SFB', 'SNAPSHOT_FOR_RESUMERE...', 'SRR', 'SNAPSHOT_FOR_SECONDARY', 'SFS', PURPOSE) P, MAP(INITIATION, 'EXCECUTED_EXPLICITLY', 'E', 'EXECUTED_EXPLICITLY', 'E', 'TRIGGERED_TIMEBASED', 'T', INITIATION) I, AGGREGATION_TYPE AGG, LPAD(TO_DECIMAL(RETRIES, 10, 2), 11) RETRIES, LPAD(TO_DECIMAL(DURATION_S, 12, 2), 11) TOTAL_S, LPAD(TO_DECIMAL(BLOCKING_PHASE_S, 12, 2), 10) BLK_S, LPAD(TO_DECIMAL(WAIT_FOR_LOCK_PHASE_S, 12, 2), 10) LOCK_S, LPAD(TO_DECIMAL(CRITICAL_PHASE_S, 12, 2), 10) CRIT_S, LPAD(TO_DECIMAL(ROUND(SIZE_MB), 11, 0), 10) SIZE_MB, LPAD(TO_DECIMAL(MB_PER_S, 10, 2), 8) MB_PER_S, LPAD(TO_DECIMAL(RS_SIZE_PCT, 12, 2), 11) RS_SIZE_PCT FROM ( SELECT CASE WHEN NUM_SAVEPOINTS = 1 THEN CRIT_PHASE_START_TIME ELSE 'various' END CRIT_PHASE_START_TIME, CASE WHEN NUM_SAVEPOINTS = 1 THEN BLK_PHASE_START_TIME ELSE 'various' END BLK_PHASE_START_TIME, CASE WHEN NUM_SAVEPOINTS = 1 THEN END_TIME ELSE 'various' END END_TIME, START_TIME, HOST, PORT, VERSION, NUM_SAVEPOINTS, INITIATION, PURPOSE, RETRIES, DURATION_S, BLOCKING_PHASE_S, WAIT_FOR_LOCK_PHASE_S, CRITICAL_PHASE_S, SIZE_MB, MAP(DURATION_S, 0, 0, SIZE_MB / DURATION_S) MB_PER_S, MAP(SIZE_MB, 0, 0, RS_SIZE_MB / SIZE_MB * 100) RS_SIZE_PCT, AGGREGATION_TYPE FROM ( SELECT CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TIME') != 0 THEN CASE WHEN BI.TIME_AGGREGATE_BY LIKE 'TS%' THEN TO_VARCHAR(ADD_SECONDS(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), FLOOR(SECONDS_BETWEEN(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(SP.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE SP.START_TIME END) / SUBSTR(BI.TIME_AGGREGATE_BY, 3)) * SUBSTR(BI.TIME_AGGREGATE_BY, 3)), 'YYYY/MM/DD HH24:MI:SS') ELSE TO_VARCHAR(CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(SP.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE SP.START_TIME END, BI.TIME_AGGREGATE_BY) END ELSE 'any' END START_TIME, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'HOST') != 0 THEN SP.HOST ELSE MAP(BI.HOST, '%', 'any', BI.HOST) END HOST, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'PORT') != 0 THEN TO_VARCHAR(SP.PORT) ELSE MAP(BI.PORT, '%', 'any', BI.PORT) END PORT, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'INITIATION') != 0 THEN SP.INITIATION ELSE MAP(BI.INITIATION, '%', 'any', BI.INITIATION) END INITIATION, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'PURPOSE') != 0 THEN SP.PURPOSE ELSE MAP(BI.PURPOSE, '%', 'any', BI.PURPOSE) END PURPOSE, TO_VARCHAR(MIN(SP.BLOCKING_PHASE_START_TIME), 'YYYY/MM/DD HH24:MI:SS') BLK_PHASE_START_TIME, TO_VARCHAR(MIN(SP.CRITICAL_PHASE_START_TIME), 'YYYY/MM/DD HH24:MI:SS') CRIT_PHASE_START_TIME, TO_VARCHAR(MIN(SP.END_TIME), 'YYYY/MM/DD HH24:MI:SS') END_TIME, BI.AGGREGATION_TYPE, COUNT(*) NUM_SAVEPOINTS, MAP(MIN(SP.VERSION), MAX(SP.VERSION), TO_VARCHAR(MIN(SP.VERSION)), 'any') VERSION, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(SP.DURATION), 'SUM', SUM(SP.DURATION), 'AVG', AVG(SP.DURATION)) / 1000000 DURATION_S, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(SP.BLOCKING_PHASE_DURATION), 'SUM', SUM(SP.BLOCKING_PHASE_DURATION), 'AVG', AVG(SP.BLOCKING_PHASE_DURATION)) / 1000000 BLOCKING_PHASE_S, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(SP.WAIT_FOR_LOCK_DURATION), 'SUM', SUM(SP.WAIT_FOR_LOCK_DURATION), 'AVG', AVG(SP.WAIT_FOR_LOCK_DURATION)) / 1000000 WAIT_FOR_LOCK_PHASE_S, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(SP.CRITICAL_PHASE_DURATION), 'SUM', SUM(SP.CRITICAL_PHASE_DURATION), 'AVG', AVG(SP.CRITICAL_PHASE_DURATION)) / 1000000 CRITICAL_PHASE_S, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(SP.TOTAL_SIZE), 'SUM', SUM(SP.TOTAL_SIZE), 'AVG', AVG(SP.TOTAL_SIZE)) / 1024 / 1024 SIZE_MB, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(SP.FLUSHED_ROWSTORE_SIZE), 'SUM', SUM(SP.FLUSHED_ROWSTORE_SIZE), 'AVG', AVG(SP.FLUSHED_ROWSTORE_SIZE)) / 1024 / 1024 RS_SIZE_MB, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(SP.RETRY_COUNT), 'SUM', SUM(SP.RETRY_COUNT), 'AVG', AVG(SP.RETRY_COUNT)) RETRIES FROM ( SELECT CASE WHEN BEGIN_TIME = 'C' THEN CURRENT_TIMESTAMP WHEN BEGIN_TIME LIKE 'C-S%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-S')) WHEN BEGIN_TIME LIKE 'C-M%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-M') * 60) WHEN BEGIN_TIME LIKE 'C-H%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-H') * 3600) WHEN BEGIN_TIME LIKE 'C-D%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-D') * 86400) WHEN BEGIN_TIME LIKE 'C-W%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-W') * 86400 * 7) WHEN BEGIN_TIME LIKE 'E-S%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-S')) WHEN BEGIN_TIME LIKE 'E-M%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-M') * 60) WHEN BEGIN_TIME LIKE 'E-H%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-H') * 3600) WHEN BEGIN_TIME LIKE 'E-D%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-D') * 86400) WHEN BEGIN_TIME LIKE 'E-W%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-W') * 86400 * 7) WHEN BEGIN_TIME = 'MIN' THEN TO_TIMESTAMP('1000/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS') WHEN SUBSTR(BEGIN_TIME, 1, 1) NOT IN ('C', 'E', 'M') THEN TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS') END BEGIN_TIME, CASE WHEN END_TIME = 'C' THEN CURRENT_TIMESTAMP WHEN END_TIME LIKE 'C-S%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-S')) WHEN END_TIME LIKE 'C-M%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-M') * 60) WHEN END_TIME LIKE 'C-H%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-H') * 3600) WHEN END_TIME LIKE 'C-D%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-D') * 86400) WHEN END_TIME LIKE 'C-W%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-W') * 86400 * 7) WHEN END_TIME LIKE 'B+S%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+S')) WHEN END_TIME LIKE 'B+M%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+M') * 60) WHEN END_TIME LIKE 'B+H%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+H') * 3600) WHEN END_TIME LIKE 'B+D%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+D') * 86400) WHEN END_TIME LIKE 'B+W%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+W') * 86400 * 7) WHEN END_TIME = 'MAX' THEN TO_TIMESTAMP('9999/12/31 00:00:00', 'YYYY/MM/DD HH24:MI:SS') WHEN SUBSTR(END_TIME, 1, 1) NOT IN ('C', 'B', 'M') THEN TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS') END END_TIME, HOST, PORT, VERSION, TIMEZONE, MIN_BLOCKING_PHASE_DURATION_S, MIN_WAIT_FOR_LOCK_PHASE_DURATION_S, MIN_CRITICAL_PHASE_DURATION_S, MIN_SAVEPOINT_DURATION_S, MIN_WRITE_SIZE_GB, MIN_RETRY_COUNT, INITIATION, PURPOSE, DATA_SOURCE, AGGREGATION_TYPE, AGGREGATE_BY, MAP(TIME_AGGREGATE_BY, 'NONE', 'YYYY/MM/DD HH24:MI:SS:FF7', 'HOUR', 'YYYY/MM/DD HH24', 'DAY', 'YYYY/MM/DD (DY)', 'HOUR_OF_DAY', 'HH24', TIME_AGGREGATE_BY ) TIME_AGGREGATE_BY FROM ( SELECT /* Modification section */ '1000/10/18 07:58:00' BEGIN_TIME, /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, E-S<seconds>, E-M<minutes>, E-H<hours>, E-D<days>, E-W<weeks>, MIN */ '9999/10/18 08:05:00' END_TIME, /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, B+S<seconds>, B+M<minutes>, B+H<hours>, B+D<days>, B+W<weeks>, MAX */ 'SERVER' TIMEZONE, /* SERVER, UTC */ '%' HOST, '%' PORT, -1 VERSION, -1 MIN_BLOCKING_PHASE_DURATION_S, -1 MIN_WAIT_FOR_LOCK_PHASE_DURATION_S, -1 MIN_CRITICAL_PHASE_DURATION_S, -1 MIN_SAVEPOINT_DURATION_S, -1 MIN_WRITE_SIZE_GB, -1 MIN_RETRY_COUNT, '%' INITIATION, '%' PURPOSE, 'CURRENT' DATA_SOURCE, /* CURRENT, HISTORY */ 'AVG' AGGREGATION_TYPE, /* MAX, AVG, SUM */ 'NONE' AGGREGATE_BY, /* HOST, PORT, TIME, INITIATION, PURPOSE or comma separated combinations, NONE for no aggregation */ 'TS900' TIME_AGGREGATE_BY /* HOUR, DAY, HOUR_OF_DAY or database time pattern, TS<seconds> for time slice, NONE for no aggregation */ FROM DUMMY ) ) BI, ( SELECT 'CURRENT' DATA_SOURCE, HOST, PORT, START_TIME, ADD_SECONDS(CRITICAL_PHASE_START_TIME, - CRITICAL_PHASE_WAIT_TIME / 1000000) BLOCKING_PHASE_START_TIME, CRITICAL_PHASE_START_TIME, ADD_SECONDS(START_TIME, DURATION / 1000000) END_TIME, DURATION, CRITICAL_PHASE_WAIT_TIME WAIT_FOR_LOCK_DURATION, CRITICAL_PHASE_DURATION, CRITICAL_PHASE_WAIT_TIME + CRITICAL_PHASE_DURATION BLOCKING_PHASE_DURATION, TOTAL_SIZE, FLUSHED_ROWSTORE_SIZE, INITIATION, PURPOSE, VERSION, PREPARE_FLUSH_RETRY_COUNT RETRY_COUNT FROM M_SAVEPOINTS UNION ALL SELECT DISTINCT 'HISTORY' DATA_SOURCE, HOST, PORT, START_TIME, ADD_SECONDS(CRITICAL_PHASE_START_TIME, - CRITICAL_PHASE_WAIT_TIME / 1000000) BLOCKING_PHASE_START_TIME, CRITICAL_PHASE_START_TIME, ADD_SECONDS(START_TIME, DURATION / 1000000) END_TIME, DURATION, CRITICAL_PHASE_WAIT_TIME WAIT_FOR_LOCK_DURATION, CRITICAL_PHASE_DURATION, CRITICAL_PHASE_WAIT_TIME + CRITICAL_PHASE_DURATION BLOCKING_PHASE_DURATION, TOTAL_SIZE, FLUSHED_ROWSTORE_SIZE, INITIATION, PURPOSE, VERSION, PREPARE_FLUSH_RETRY_COUNT RETRY_COUNT FROM _SYS_STATISTICS.HOST_SAVEPOINTS ) SP WHERE SP.HOST LIKE BI.HOST AND TO_VARCHAR(SP.PORT) LIKE BI.PORT AND CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(SP.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE SP.START_TIME END BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND SP.INITIATION LIKE BI.INITIATION AND SP.PURPOSE LIKE BI.PURPOSE AND ( BI.VERSION = -1 OR SP.VERSION = BI.VERSION ) AND ( BI.MIN_BLOCKING_PHASE_DURATION_S = -1 OR SP.BLOCKING_PHASE_DURATION / 1000000 >= BI.MIN_BLOCKING_PHASE_DURATION_S) AND ( BI.MIN_WAIT_FOR_LOCK_PHASE_DURATION_S = -1 OR SP.WAIT_FOR_LOCK_DURATION / 1000000 >= BI.MIN_WAIT_FOR_LOCK_PHASE_DURATION_S ) AND ( BI.MIN_CRITICAL_PHASE_DURATION_S = -1 OR SP.CRITICAL_PHASE_DURATION / 1000000 >= BI.MIN_CRITICAL_PHASE_DURATION_S ) AND ( BI.MIN_SAVEPOINT_DURATION_S = -1 OR SP.DURATION / 1000000 >= BI.MIN_SAVEPOINT_DURATION_S ) AND ( BI.MIN_WRITE_SIZE_GB = -1 OR SP.TOTAL_SIZE / 1024 / 1024 / 1024 >= BI.MIN_WRITE_SIZE_GB ) AND ( BI.MIN_RETRY_COUNT = -1 OR SP.RETRY_COUNT >= BI.MIN_RETRY_COUNT ) AND SP.DATA_SOURCE = BI.DATA_SOURCE GROUP BY CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TIME') != 0 THEN CASE WHEN BI.TIME_AGGREGATE_BY LIKE 'TS%' THEN TO_VARCHAR(ADD_SECONDS(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), FLOOR(SECONDS_BETWEEN(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(SP.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE SP.START_TIME END) / SUBSTR(BI.TIME_AGGREGATE_BY, 3)) * SUBSTR(BI.TIME_AGGREGATE_BY, 3)), 'YYYY/MM/DD HH24:MI:SS') ELSE TO_VARCHAR(CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(SP.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE SP.START_TIME END, BI.TIME_AGGREGATE_BY) END ELSE 'any' END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'HOST') != 0 THEN SP.HOST ELSE MAP(BI.HOST, '%', 'any', BI.HOST) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'PORT') != 0 THEN TO_VARCHAR(SP.PORT) ELSE MAP(BI.PORT, '%', 'any', BI.PORT) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'INITIATION') != 0 THEN SP.INITIATION ELSE MAP(BI.INITIATION, '%', 'any', BI.INITIATION) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'PURPOSE') != 0 THEN SP.PURPOSE ELSE MAP(BI.PURPOSE, '%', 'any', BI.PURPOSE) END, BI.AGGREGATION_TYPE ) ) ORDER BY START_TIME DESC, HOST, PORT"
                     }
                }
            ]
        },
        {
            "name": "DeltaMerge",
            "description": "SAP HANA delta merge issue",
            "customLog": "SapHana_DeltaMerge_Count",
            "frequencySecs": 3600,
            "includeInCustomerAnalytics": false,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT START_TIME, END_TIME, LPAD(TO_DECIMAL(DURATION_S, 10, 2), 10) DURATION_S, HOST, PORT, LPAD(NUM, 7) COUNT, TYPE, MOTIVATION, SCHEMA_NAME, TABLE_NAME, LPAD(TO_DECIMAL(ROUND(RECORDS_MERGED), 11, 0), 11) ROWS_MERGED, LAST_ERROR FROM ( SELECT CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TIME') != 0 THEN CASE WHEN BI.TIME_AGGREGATE_BY LIKE 'TS%' THEN TO_VARCHAR(ADD_SECONDS(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), FLOOR(SECONDS_BETWEEN(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(M.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE M.START_TIME END) / SUBSTR(BI.TIME_AGGREGATE_BY, 3)) * SUBSTR(BI.TIME_AGGREGATE_BY, 3)), 'YYYY/MM/DD HH24:MI:SS') ELSE TO_VARCHAR(CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(M.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE M.START_TIME END, BI.TIME_AGGREGATE_BY) END ELSE 'any' END START_TIME, CASE WHEN BI.AGGREGATE_BY = 'NONE' AND BI.TIME_AGGREGATE_BY_ORIG = 'NONE' THEN TO_VARCHAR(M.END_TIME, 'YYYY/MM/DD HH24:MI:SS') ELSE 'any' END END_TIME, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'HOST') != 0 THEN M.HOST ELSE MAP(BI.HOST, '%', 'any', BI.HOST) END HOST, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'PORT') != 0 THEN TO_VARCHAR(M.PORT) ELSE MAP(BI.PORT, '%', 'any', BI.PORT) END PORT, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'SCHEMA') != 0 THEN M.SCHEMA_NAME ELSE MAP(BI.SCHEMA_NAME, '%', 'any', BI.SCHEMA_NAME) END SCHEMA_NAME, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TABLE') != 0 THEN M.TABLE_NAME || MAP(BI.OBJECT_LEVEL, 'TABLE', '', MAP(M.PART_ID, 0, '', CHAR(32) || '(' || M.PART_ID || ')')) ELSE MAP(BI.TABLE_NAME, '%', 'any', BI.TABLE_NAME) END TABLE_NAME, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TYPE') != 0 THEN M.TYPE ELSE MAP(BI.MERGE_TYPE, '%', 'any', BI.MERGE_TYPE) END TYPE, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'MOTIVATION') != 0 THEN M.MOTIVATION ELSE MAP(BI.MERGE_MOTIVATION, '%', 'any', BI.MERGE_MOTIVATION) END MOTIVATION, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'ERROR') != 0 THEN M.LAST_ERROR ELSE MAP(BI.MERGE_ERROR, '%', 'any', BI.MERGE_ERROR) END LAST_ERROR, COUNT(*) NUM, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(M.DURATION_S), 'AVG', AVG(M.DURATION_S), 'SUM', SUM(M.DURATION_S)) DURATION_S, MAP(BI.AGGREGATION_TYPE, 'MAX', MAX(M.RECORDS_MERGED), 'AVG', AVG(M.RECORDS_MERGED), 'SUM', SUM(RECORDS_MERGED)) RECORDS_MERGED, BI.ORDER_BY FROM ( SELECT CASE WHEN BEGIN_TIME = 'C' THEN CURRENT_TIMESTAMP WHEN BEGIN_TIME LIKE 'C-S%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-S')) WHEN BEGIN_TIME LIKE 'C-M%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-M') * 60) WHEN BEGIN_TIME LIKE 'C-H%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-H') * 3600) WHEN BEGIN_TIME LIKE 'C-D%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-D') * 86400) WHEN BEGIN_TIME LIKE 'C-W%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-W') * 86400 * 7) WHEN BEGIN_TIME LIKE 'E-S%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-S')) WHEN BEGIN_TIME LIKE 'E-M%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-M') * 60) WHEN BEGIN_TIME LIKE 'E-H%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-H') * 3600) WHEN BEGIN_TIME LIKE 'E-D%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-D') * 86400) WHEN BEGIN_TIME LIKE 'E-W%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-W') * 86400 * 7) WHEN BEGIN_TIME = 'MIN' THEN TO_TIMESTAMP('1000/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS') WHEN SUBSTR(BEGIN_TIME, 1, 1) NOT IN ('C', 'E', 'M') THEN TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS') END BEGIN_TIME, CASE WHEN END_TIME = 'C' THEN CURRENT_TIMESTAMP WHEN END_TIME LIKE 'C-S%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-S')) WHEN END_TIME LIKE 'C-M%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-M') * 60) WHEN END_TIME LIKE 'C-H%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-H') * 3600) WHEN END_TIME LIKE 'C-D%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-D') * 86400) WHEN END_TIME LIKE 'C-W%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-W') * 86400 * 7) WHEN END_TIME LIKE 'B+S%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+S')) WHEN END_TIME LIKE 'B+M%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+M') * 60) WHEN END_TIME LIKE 'B+H%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+H') * 3600) WHEN END_TIME LIKE 'B+D%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+D') * 86400) WHEN END_TIME LIKE 'B+W%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+W') * 86400 * 7) WHEN END_TIME = 'MAX' THEN TO_TIMESTAMP('9999/12/31 00:00:00', 'YYYY/MM/DD HH24:MI:SS') WHEN SUBSTR(END_TIME, 1, 1) NOT IN ('C', 'B', 'M') THEN TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS') END END_TIME, TIMEZONE, HOST, PORT, SCHEMA_NAME, TABLE_NAME, PART_ID, MIN_MERGE_DURATION_S, MIN_RECORDS_MERGED, MERGE_TYPE, MERGE_MOTIVATION, MERGE_ERROR, ONLY_FAILED_MERGES, ONLY_CRITICAL_ERRORS, OBJECT_LEVEL, DATA_SOURCE, AGGREGATE_BY, MAP(TIME_AGGREGATE_BY, 'NONE', 'YYYY/MM/DD HH24:MI:SS.FF3', 'HOUR', 'YYYY/MM/DD HH24', 'DAY', 'YYYY/MM/DD (DY)', 'HOUR_OF_DAY', 'HH24', TIME_AGGREGATE_BY ) TIME_AGGREGATE_BY, TIME_AGGREGATE_BY TIME_AGGREGATE_BY_ORIG, AGGREGATION_TYPE, ORDER_BY FROM ( SELECT /* Modification section */ '1000/10/18 07:58:00' BEGIN_TIME, /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, E-S<seconds>, E-M<minutes>, E-H<hours>, E-D<days>, E-W<weeks>, MIN */ '9999/10/18 08:05:00' END_TIME, /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, B+S<seconds>, B+M<minutes>, B+H<hours>, B+D<days>, B+W<weeks>, MAX */ 'SERVER' TIMEZONE, /* SERVER, UTC */ '%' HOST, '%' PORT, '%' SCHEMA_NAME, '%' TABLE_NAME, -1 PART_ID, -1 MIN_MERGE_DURATION_S, -1 MIN_RECORDS_MERGED, '%' MERGE_TYPE, /* MERGE, HINT, SPARSE, RECLAIM */ '%' MERGE_MOTIVATION, /* AUTO, SMART, HARD, FORCED, CRITICAL, FORCED+HARD */ '%' MERGE_ERROR, ' ' ONLY_FAILED_MERGES, ' ' ONLY_CRITICAL_ERRORS, 'TABLE' OBJECT_LEVEL, 'HISTORY' DATA_SOURCE, 'MOTIVATION, TIME' AGGREGATE_BY, /* TIME, HOST, PORT, SCHEMA, TABLE, TYPE, MOTIVATION, ERROR and comma-separated combinations, NONE for no aggregation */ 'DAY' TIME_AGGREGATE_BY, /* HOUR, DAY, HOUR_OF_DAY or database time pattern, TS<seconds> for time slice, NONE for no aggregation */ 'SUM' AGGREGATION_TYPE, /* MAX, AVG, SUM */ 'TIME' ORDER_BY /* TIME, TABLE, COUNT, DURATION, ROWS */ FROM DUMMY ) ) BI, ( SELECT 'CURRENT' DATA_SOURCE, HOST, PORT, SCHEMA_NAME, TABLE_NAME, PART_ID, START_TIME, EXECUTION_TIME / 1000 DURATION_S, ADD_SECONDS(START_TIME, EXECUTION_TIME / 1000) END_TIME, TYPE, MOTIVATION, TO_BIGINT(GREATEST(0, MERGED_DELTA_RECORDS)) RECORDS_MERGED, MAP(LAST_ERROR, '0', '0', LAST_ERROR || CHAR(32) || ERROR_DESCRIPTION) LAST_ERROR FROM M_DELTA_MERGE_STATISTICS UNION ALL ( SELECT DISTINCT 'HISTORY' DATA_SOURCE, HOST, PORT, SCHEMA_NAME, TABLE_NAME, PART_ID, START_TIME, EXECUTION_TIME / 1000 DURATION_S, ADD_SECONDS(START_TIME, EXECUTION_TIME / 1000) END_TIME, TYPE, MOTIVATION, TO_BIGINT(GREATEST(0, MERGED_DELTA_RECORDS)) RECORDS_MERGED, MAP(LAST_ERROR, '0', '0', LAST_ERROR || CHAR(32) || ERROR_DESCRIPTION) LAST_ERROR FROM _SYS_STATISTICS.HOST_DELTA_MERGE_STATISTICS ) ) M WHERE M.HOST LIKE BI.HOST AND M.SCHEMA_NAME LIKE BI.SCHEMA_NAME AND M.TABLE_NAME LIKE BI.TABLE_NAME AND ( BI.PART_ID = -1 OR M.PART_ID = BI.PART_ID ) AND TO_VARCHAR(M.PORT) LIKE BI.PORT AND CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(M.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE M.START_TIME END BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND M.DATA_SOURCE LIKE BI.DATA_SOURCE AND M.TYPE LIKE BI.MERGE_TYPE AND ( M.MOTIVATION LIKE BI.MERGE_MOTIVATION OR M.MOTIVATION IN ( 'FORCED', 'HARD' ) AND BI.MERGE_MOTIVATION = 'FORCED+HARD' ) AND M.LAST_ERROR LIKE BI.MERGE_ERROR AND ( BI.MIN_MERGE_DURATION_S = -1 OR M.DURATION_S >= BI.MIN_MERGE_DURATION_S ) AND ( BI.MIN_RECORDS_MERGED = -1 OR M.RECORDS_MERGED >= BI.MIN_RECORDS_MERGED ) AND ( BI.ONLY_FAILED_MERGES = ' ' OR M.LAST_ERROR != '0' ) AND ( BI.ONLY_CRITICAL_ERRORS = ' ' OR ( M.LAST_ERROR != '0' AND M.LAST_ERROR NOT LIKE '%2465%' AND M.LAST_ERROR NOT LIKE '%2480%' AND M.LAST_ERROR NOT LIKE '%2481%' AND M.LAST_ERROR NOT LIKE '%2482%' AND M.LAST_ERROR NOT LIKE '%2486%' ) ) GROUP BY CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TIME') != 0 THEN CASE WHEN BI.TIME_AGGREGATE_BY LIKE 'TS%' THEN TO_VARCHAR(ADD_SECONDS(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), FLOOR(SECONDS_BETWEEN(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(M.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE M.START_TIME END) / SUBSTR(BI.TIME_AGGREGATE_BY, 3)) * SUBSTR(BI.TIME_AGGREGATE_BY, 3)), 'YYYY/MM/DD HH24:MI:SS') ELSE TO_VARCHAR(CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(M.START_TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE M.START_TIME END, BI.TIME_AGGREGATE_BY) END ELSE 'any' END, CASE WHEN BI.AGGREGATE_BY = 'NONE' AND BI.TIME_AGGREGATE_BY_ORIG = 'NONE' THEN TO_VARCHAR(M.END_TIME, 'YYYY/MM/DD HH24:MI:SS') ELSE 'any' END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'HOST') != 0 THEN M.HOST ELSE MAP(BI.HOST, '%', 'any', BI.HOST) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'PORT') != 0 THEN TO_VARCHAR(M.PORT) ELSE MAP(BI.PORT, '%', 'any', BI.PORT) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'SCHEMA') != 0 THEN M.SCHEMA_NAME ELSE MAP(BI.SCHEMA_NAME, '%', 'any', BI.SCHEMA_NAME) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TABLE') != 0 THEN M.TABLE_NAME || MAP(BI.OBJECT_LEVEL, 'TABLE', '', MAP(M.PART_ID, 0, '', CHAR(32) || '(' || M.PART_ID || ')')) ELSE MAP(BI.TABLE_NAME, '%', 'any', BI.TABLE_NAME) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TYPE') != 0 THEN M.TYPE ELSE MAP(BI.MERGE_TYPE, '%', 'any', BI.MERGE_TYPE) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'MOTIVATION') != 0 THEN M.MOTIVATION ELSE MAP(BI.MERGE_MOTIVATION, '%', 'any', BI.MERGE_MOTIVATION) END, CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'ERROR') != 0 THEN M.LAST_ERROR ELSE MAP(BI.MERGE_ERROR, '%', 'any', BI.MERGE_ERROR) END, BI.AGGREGATION_TYPE, BI.ORDER_BY ) ORDER BY MAP(ORDER_BY, 'TIME', START_TIME) DESC, MAP(ORDER_BY, 'TABLE', TABLE_NAME), MAP(ORDER_BY, 'COUNT', NUM, 'DURATION', DURATION_S, 'ROWS', RECORDS_MERGED) DESC"
                     }
                }
            ]
        },
        {
            "name": "NonPartitioned500M",
            "description": "Tables having more than 500M records which impacts the performance of the application server",
            "customLog": "SapHana_NonPartitioned_Tables",
            "frequencySecs": 86400,
            "includeInCustomerAnalytics": false,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT MAP(A.ROW_NUM, 1, TO_VARCHAR(MAX(CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(A.ALERT_TIMESTAMP, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE A.ALERT_TIMESTAMP END), 'YYYY/MM/DD HH24:MI:SS'), '') ALERT_TIME, MAP(A.ROW_NUM, 1, A.DATABASE_NAME, '') DB_NAME, MAP(A.ROW_NUM, 1, LPAD(A.ALERT_ID, 8), '') ALERT_ID, MAP(A.ROW_NUM, 1, MAP(A.ALERT_RATING, 1, 'INFO', 2, 'LOW', 3, 'MEDIUM', 4, 'HIGH', 5, 'ERROR'), '') RATING, A.ALERT_DETAILS, IFNULL(A.RECOMMENDATION, '') RECOMMENDATION FROM ( SELECT CASE WHEN BEGIN_TIME = 'C' THEN CURRENT_TIMESTAMP WHEN BEGIN_TIME LIKE 'C-S%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-S')) WHEN BEGIN_TIME LIKE 'C-M%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-M') * 60) WHEN BEGIN_TIME LIKE 'C-H%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-H') * 3600) WHEN BEGIN_TIME LIKE 'C-D%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-D') * 86400) WHEN BEGIN_TIME LIKE 'C-W%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-W') * 86400 * 7) WHEN BEGIN_TIME LIKE 'E-S%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-S')) WHEN BEGIN_TIME LIKE 'E-M%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-M') * 60) WHEN BEGIN_TIME LIKE 'E-H%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-H') * 3600) WHEN BEGIN_TIME LIKE 'E-D%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-D') * 86400) WHEN BEGIN_TIME LIKE 'E-W%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-W') * 86400 * 7) WHEN BEGIN_TIME = 'MIN' THEN TO_TIMESTAMP('1000/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS') WHEN SUBSTR(BEGIN_TIME, 1, 1) NOT IN ('C', 'E', 'M') THEN TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS') END BEGIN_TIME, CASE WHEN END_TIME = 'C' THEN CURRENT_TIMESTAMP WHEN END_TIME LIKE 'C-S%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-S')) WHEN END_TIME LIKE 'C-M%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-M') * 60) WHEN END_TIME LIKE 'C-H%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-H') * 3600) WHEN END_TIME LIKE 'C-D%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-D') * 86400) WHEN END_TIME LIKE 'C-W%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-W') * 86400 * 7) WHEN END_TIME LIKE 'B+S%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+S')) WHEN END_TIME LIKE 'B+M%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+M') * 60) WHEN END_TIME LIKE 'B+H%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+H') * 3600) WHEN END_TIME LIKE 'B+D%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+D') * 86400) WHEN END_TIME LIKE 'B+W%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+W') * 86400 * 7) WHEN END_TIME = 'MAX' THEN TO_TIMESTAMP('9999/12/31 00:00:00', 'YYYY/MM/DD HH24:MI:SS') WHEN SUBSTR(END_TIME, 1, 1) NOT IN ('C', 'B', 'M') THEN TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS') END END_TIME, TIMEZONE, DB_NAME, ALERT_ID, RECOMMENDATION, MIN_SEVERITY_LEVEL, ORDER_BY FROM ( SELECT /* Modification section */ '1000/10/18 07:58:00' BEGIN_TIME, /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, E-S<seconds>, E-M<minutes>, E-H<hours>, E-D<days>, E-W<weeks>, MIN */ '9999/10/18 08:05:00' END_TIME, /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, B+S<seconds>, B+M<minutes>, B+H<hours>, B+D<days>, B+W<weeks>, MAX */ 'SERVER' TIMEZONE, /* SERVER, UTC */ '%' DB_NAME, -1 ALERT_ID, '%' RECOMMENDATION, 'LOW' MIN_SEVERITY_LEVEL, /* INFO, LOW, MEDIUM, HIGH, ERROR */ 'TIME' ORDER_BY /* SEVERITY, TIME */ FROM DUMMY ) ) BI, ( SELECT R.ROW_NUM, A.ALERT_TIMESTAMP, A.DATABASE_NAME, A.ALERT_ID, A.ALERT_RATING, A.ALERT_DETAILS ALERT_DETAILS_TOTAL, SUBSTR(A.ALERT_DETAILS, (R.ROW_NUM - 1) * 100 + 1, 100) ALERT_DETAILS, SUBSTR(A.ALERT_USERACTION, (R.ROW_NUM - 1) * 100 + 1, 100) RECOMMENDATION FROM ( SELECT TOP 10 ROW_NUMBER () OVER () ROW_NUM FROM M_HOST_INFORMATION ) R, ( SELECT A.DATABASE_NAME, A.ALERT_ID, A.ALERT_TIMESTAMP, A.ALERT_RATING, A.ALERT_DETAILS, CA.ALERT_USERACTION FROM SYS_DATABASES.STATISTICS_ALERTS A LEFT OUTER JOIN SYS_DATABASES.STATISTICS_CURRENT_ALERTS CA ON A.DATABASE_NAME = CA.DATABASE_NAME AND A.ALERT_ID = CA.ALERT_ID AND A.INDEX = CA.INDEX AND A.SNAPSHOT_ID = CA.SNAPSHOT_ID ) A WHERE SUBSTR(A.ALERT_DETAILS, (R.ROW_NUM - 1) * 100 + 1, 100) != '' OR SUBSTR(A.ALERT_USERACTION, (R.ROW_NUM - 1) * 100 + 1, 100) != '' ) A WHERE A.DATABASE_NAME LIKE BI.DB_NAME AND CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(A.ALERT_TIMESTAMP, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE A.ALERT_TIMESTAMP END BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND ( BI.MIN_SEVERITY_LEVEL = 'INFO' OR BI.MIN_SEVERITY_LEVEL = 'LOW' AND A.ALERT_RATING >= 2 OR BI.MIN_SEVERITY_LEVEL = 'MEDIUM' AND A.ALERT_RATING >= 3 OR BI.MIN_SEVERITY_LEVEL = 'HIGH' AND A.ALERT_RATING >= 4 OR BI.MIN_SEVERITY_LEVEL = 'ERROR' AND A.ALERT_RATING = 5 ) AND UPPER(IFNULL(A.RECOMMENDATION, '')) LIKE UPPER(BI.RECOMMENDATION) AND ( BI.ALERT_ID = -1 OR A.ALERT_ID = BI.ALERT_ID ) GROUP BY A.ROW_NUM, A.DATABASE_NAME, A.ALERT_ID, A.ALERT_RATING, A.ALERT_DETAILS, A.ALERT_DETAILS_TOTAL, A.RECOMMENDATION, BI.ORDER_BY ORDER BY MAP(BI.ORDER_BY, 'TIME', MAX(A.ALERT_TIMESTAMP)) DESC, A.ALERT_RATING DESC, A.ALERT_ID, A.ALERT_DETAILS_TOTAL, A.ROW_NUM"
                    }
                }
            ]
        },
        {
            "name": "TablesPartitionSizeStatus",
            "description": "SAP HANA tables & partitions size status",
            "customLog": "SapHana_Tables_Partitions_Size",
            "frequencySecs": 86400,
            "includeInCustomerAnalytics": false,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "SELECT MAP(A.ROW_NUM, 1, TO_VARCHAR(MAX(CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(A.ALERT_TIMESTAMP, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE A.ALERT_TIMESTAMP END), 'YYYY/MM/DD HH24:MI:SS'), '') ALERT_TIME, MAP(A.ROW_NUM, 1, LPAD(A.ALERT_ID, 8), '') ALERT_ID, MAP(A.ROW_NUM, 1, MAP(A.ALERT_RATING, 1, 'INFO', 2, 'LOW', 3, 'MEDIUM', 4, 'HIGH', 5, 'ERROR'), '') RATING, A.ALERT_DETAILS, IFNULL(A.RECOMMENDATION, '') RECOMMENDATION FROM ( SELECT CASE WHEN BEGIN_TIME = 'C' THEN CURRENT_TIMESTAMP WHEN BEGIN_TIME LIKE 'C-S%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-S')) WHEN BEGIN_TIME LIKE 'C-M%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-M') * 60) WHEN BEGIN_TIME LIKE 'C-H%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-H') * 3600) WHEN BEGIN_TIME LIKE 'C-D%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-D') * 86400) WHEN BEGIN_TIME LIKE 'C-W%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-W') * 86400 * 7) WHEN BEGIN_TIME LIKE 'E-S%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-S')) WHEN BEGIN_TIME LIKE 'E-M%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-M') * 60) WHEN BEGIN_TIME LIKE 'E-H%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-H') * 3600) WHEN BEGIN_TIME LIKE 'E-D%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-D') * 86400) WHEN BEGIN_TIME LIKE 'E-W%' THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-W') * 86400 * 7) WHEN BEGIN_TIME = 'MIN' THEN TO_TIMESTAMP('1000/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS') WHEN SUBSTR(BEGIN_TIME, 1, 1) NOT IN ('C', 'E', 'M') THEN TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS') END BEGIN_TIME, CASE WHEN END_TIME = 'C' THEN CURRENT_TIMESTAMP WHEN END_TIME LIKE 'C-S%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-S')) WHEN END_TIME LIKE 'C-M%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-M') * 60) WHEN END_TIME LIKE 'C-H%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-H') * 3600) WHEN END_TIME LIKE 'C-D%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-D') * 86400) WHEN END_TIME LIKE 'C-W%' THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-W') * 86400 * 7) WHEN END_TIME LIKE 'B+S%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+S')) WHEN END_TIME LIKE 'B+M%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+M') * 60) WHEN END_TIME LIKE 'B+H%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+H') * 3600) WHEN END_TIME LIKE 'B+D%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+D') * 86400) WHEN END_TIME LIKE 'B+W%' THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+W') * 86400 * 7) WHEN END_TIME = 'MAX' THEN TO_TIMESTAMP('9999/12/31 00:00:00', 'YYYY/MM/DD HH24:MI:SS') WHEN SUBSTR(END_TIME, 1, 1) NOT IN ('C', 'B', 'M') THEN TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS') END END_TIME, TIMEZONE, ALERT_ID, RECOMMENDATION, MIN_SEVERITY_LEVEL, ORDER_BY FROM ( SELECT /* Modification section */ '1000/10/18 07:58:00' BEGIN_TIME, /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, E-S<seconds>, E-M<minutes>, E-H<hours>, E-D<days>, E-W<weeks>, MIN */ '9999/10/18 08:05:00' END_TIME, /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, B+S<seconds>, B+M<minutes>, B+H<hours>, B+D<days>, B+W<weeks>, MAX */ 'SERVER' TIMEZONE, /* SERVER, UTC */ -1 ALERT_ID, '%' RECOMMENDATION, 'LOW' MIN_SEVERITY_LEVEL, /* INFO, LOW, MEDIUM, HIGH, ERROR */ 'TIME' ORDER_BY /* SEVERITY, TIME */ FROM DUMMY ) ) BI, ( SELECT R.ROW_NUM, A.ALERT_TIMESTAMP, A.ALERT_ID, A.ALERT_RATING, A.ALERT_DETAILS ALERT_DETAILS_TOTAL, SUBSTR(A.ALERT_DETAILS, (R.ROW_NUM - 1) * 100 + 1, 100) ALERT_DETAILS, SUBSTR(A.ALERT_USERACTION, (R.ROW_NUM - 1) * 100 + 1, 100) RECOMMENDATION FROM ( SELECT TOP 10 ROW_NUMBER () OVER () ROW_NUM FROM M_HOST_INFORMATION ) R, ( SELECT A.ALERT_ID, A.ALERT_TIMESTAMP, A.ALERT_RATING, A.ALERT_DETAILS, CA.ALERT_USERACTION FROM _SYS_STATISTICS.STATISTICS_ALERTS_BASE A LEFT OUTER JOIN _SYS_STATISTICS.STATISTICS_CURRENT_ALERTS CA ON A.ALERT_ID = CA.ALERT_ID AND A.INDEX = CA.INDEX AND A.SNAPSHOT_ID = CA.SNAPSHOT_ID ) A WHERE SUBSTR(A.ALERT_DETAILS, (R.ROW_NUM - 1) * 100 + 1, 100) != '' OR SUBSTR(A.ALERT_USERACTION, (R.ROW_NUM - 1) * 100 + 1, 100) != '' ) A WHERE CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(A.ALERT_TIMESTAMP, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE A.ALERT_TIMESTAMP END BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND ( BI.MIN_SEVERITY_LEVEL = 'INFO' OR BI.MIN_SEVERITY_LEVEL = 'LOW' AND A.ALERT_RATING >= 2 OR BI.MIN_SEVERITY_LEVEL = 'MEDIUM' AND A.ALERT_RATING >= 3 OR BI.MIN_SEVERITY_LEVEL = 'HIGH' AND A.ALERT_RATING >= 4 OR BI.MIN_SEVERITY_LEVEL = 'ERROR' AND A.ALERT_RATING = 5 ) AND UPPER(IFNULL(A.RECOMMENDATION, '')) LIKE UPPER(BI.RECOMMENDATION) AND ( BI.ALERT_ID = -1 OR A.ALERT_ID = BI.ALERT_ID ) GROUP BY A.ROW_NUM, A.ALERT_ID, A.ALERT_RATING, A.ALERT_DETAILS, A.ALERT_DETAILS_TOTAL, A.RECOMMENDATION, BI.ORDER_BY ORDER BY MAP(BI.ORDER_BY, 'TIME', MAX(A.ALERT_TIMESTAMP)) DESC, A.ALERT_RATING DESC, A.ALERT_ID, A.ALERT_DETAILS_TOTAL, A.ROW_NUM"
                                  }
                }
            ]
        },
        {
            "name": "LicenseStatus",
            "description": "To check if enforced license is installed and current memory consumption of SAP HANA exceeds the licensed amount of memory plus some tolerance",
            "customLog": "SapHana_License_Status",
            "frequencySecs": 86400,
            "includeInCustomerAnalytics": false,
            "actions": [
                {
                    "type": "ExecuteSql",
                    "parameters": {
                        "sql": "Select hostinfo.HOST as hostname, hostinfo.VALUE as SID, SYSTEM_ID, START_DATE, EXPIRATION_DATE, PERMANENT, VALID, PRODUCT_LIMIT, PRODUCT_USAGE, HARDWARE_KEY, INSTALL_NO, SYSTEM_NO from M_LICENSES inner join M_HOST_INFORMATION hostinfo on hostinfo.key = 'sid'"
                                  }
                }
            ]
        }
    ]
}
